---
title: "Data Cleaning and Processing of RNA-Seq for Triple-Negative Breast Cancer"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
    theme: flatly
    highlight: tango
    fig_caption: true
    df_print: paged 
    code_folding: show
bibliography: references.bib
nocite: '@*'
---

While cancer is one of the most studied diseases in the world, the immune landscape of cancer patients is largely uncharacterized. Previous research has demonstrated that tumours can affect the immune system's response, leading to variations in disease progression and treatment outcomes [@blomberg2018, @mcallister2014].

Neutrophils are a type of white blood cell that play a critical role in the body's immune response [@nci2019]. They respond to conditions in the body by releasing enzymes to destroy microorganisms [@nci2019]. Neutrophils also help to activate other immune cells, making them vital to the immune system [@nci2019]. 

Triple-Negative Breast Cancer (TNBC) is a particularly aggressive breast cancer subtype with a high mortality rate [@acs2023]. To investigate immune response in TNBC patients, Bakker et. al performed a bulk RNA-seq experiment designed to identify the differences in the expression of genes in the neutrophils of TNBC patients and healthy donors [@bakker2025]. 

In this analysis, we continue the work of Bakker et. al by examining their bulk RNA-sequencing results to investigate the expression patterns of genes in TNBC patients.

---

# Dataset Import

Bakker et. al conducted a bulk RNA-sequencing experiment involving neutrophils from seven patients with metastatic TNBC (mTNBC). Of the mTNBC pateints, one sample was chemotherapy-na√Øve, one was chemo-free for more than 1 year, and the remaining 5 received recent chemotherapy [@bakker2025]. They also sequenced the neutrophils from seven healthy donors (HDs) for a control group [@bakker2025]. 

We begin by importing relevant packages for our analysis. We will be using GEOquery [@geoquery] to retrieve the GEO data; edgeR [@edgeR] for normalization; ggplot2 [@ggplot2] for plotting; and reshape2 [@reshape2], tidyr [@tidyr], and dplyr [@dplyr] for data manipulation.
```{r, message=FALSE, warning=FALSE, error=FALSE, results='hide'}
library(GEOquery)
library(edgeR)
library(ggplot2)
library(reshape2)
library(tidyr)
library(dplyr)
```

The results for this experiment are stored in GEO with accession number `GSE264108`. We will retrieve the meta-data for this experiemnt and examine the summary of the experiment we are accessing.
```{r, message=FALSE, warning=FALSE}
data_set_geoid <- "GSE264108"
# retrieve data from GEO
gse <- getGEO(data_set_geoid, GSEMatrix = FALSE)
gse@header$summary
```

There are two bulk RNA-sequencing datasets associated with this paper, raw counts and normalized counts. We will be using the raw counts, since we will be doing the cleaning and normalization from scratch. If the file is downloaded already, the following code will simply import it from your system.

```{r, message=FALSE, warning=FALSE}
# retrieve the dataset filenames
sfilenames <- getGEOSuppFiles(data_set_geoid, fetch_files = FALSE)

# set dataset filename and working directory for retrieval
data_filename <- sfilenames$fname[1]
#data_filename <- "GSE264108_readcounts.txt.gz"
download_dir <- file.path(getwd())

# check if the file exists before downloading
if(!file.exists(file.path(download_dir,data_set_geoid, data_filename))){
  sfiles = getGEOSuppFiles(data_set_geoid,
                           baseDir = download_dir, 
                           fetch_files = TRUE)
}

# read in tab-separated data 
tnbc_data <- read.table(
  file.path(download_dir,data_set_geoid,data_filename),
  header=TRUE,
  sep="\t",
  check.names=TRUE)
dim(tnbc_data)
```

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*

This dataset contains `9048` genes.

---

# Dataset Cleaning

In order to better understand the data we are working with, we will begin by cleaning up the table as it is now. The raw format of the data can be seen below.

```{r, message=FALSE, warning=FALSE}
head(tnbc_data)
```

There are 14 samples, as well as meta-data for each gene in the data set. To improve our analysis, we split this data into 2 tables, one for the sample meta-data and another for the read counts.

First, we pull out the sample meta-data so that we can map each sample to a more human-readable descriptor.

```{r, message=FALSE, warning=FALSE}
# retrieve the list of samples
list_of_samples <- gse@gsms

# pull out relevant metadata for each sample
sample_type <- do.call(rbind, 
                        lapply(list_of_samples, FUN=function(x){
                          c(x@header$title,
                            x@header$characteristics_ch1)}))

# convert to a data frame
sample_df <- as.data.frame(sample_type, stringsAsFactors = FALSE)
colnames(sample_df) <- c("sample", "sampleCondition", "cellType", "diseaseState")
```

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*

Now, we perform some simple string manipulations to clean up the dataframe, and we are left with a summary of our samples.

```{r, message=FALSE, warning=FALSE}
# remove matching text to reduce redundancy
sample_df[,'sample'] <- gsub(sample_df[,'sample'],
                                pattern = "Neutrophils ",
                                replacement = "")
sample_df[,'sampleCondition'] <- gsub(sample_df[,'sampleCondition'],
                                             pattern = "tissue: ",
                                             replacement = "")
sample_df[,'cellType'] <- gsub(sample_df[,'cellType'],
                                       pattern = "cell type: ",
                                       replacement = "")
sample_df[,'diseaseState'] <- gsub(sample_df[,'diseaseState'],
                                    pattern = "disease state: ",
                                    replacement = "")

sample_df
```

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*

There are 14 samples present in this experiment, 7 from mTNBC patients and 7 from healthy donors. All samples had the same sequencing protocol, with FACS sorting done on neutrophils in the blood for each sample.

Next, we map our samples back to the read count dataframe so that we can use the accessions more easily. 

```{r, message=FALSE, warning=FALSE}
# set the colomn names of our data to the sample names
colnames(tnbc_data)[2:15] <- sample_df$sample
```

---

## Data Cleaning

Now that our dataset is in a suitable format for reading, we will clean the actual read counts in the dataset. First, we begin by analyzing the distribution of the data.

```{r, message=FALSE, warning=FALSE}
data.frame(do.call(cbind, lapply(tnbc_data[, 2:15], summary)))
```

*This code was inspired by the response by A5C1D2H2I1M1N2O1R2T1 to this Stack Overflow question [@chiam2015].*

The 1st quantile is 0 for all samples, and the mean values are very low, implying we have quite a few genes with low read counts.

Since there are 7 of each disease state, we remove any gene that does not have expression in at least 7 of the samples.

```{r, message=FALSE, warning=FALSE}
rownames(tnbc_data) <- tnbc_data$ensembl_gene_id
min_num_samples <- 7
data_matrix <- as.matrix(tnbc_data[ , 2:15])
keep = rowSums(edgeR::cpm(data_matrix) >1) > min_num_samples
filtered_tnbc_data = data.frame(data_matrix[keep,])
dim(filtered_tnbc_data)
```

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*

This leaves us with 3693 genes that have enough expression to be analyzed downstream. To confirm we have removed most of our low read counts, we can reasses the distribution of the read coutns across samples.


```{r, message=FALSE, warning=FALSE}
data.frame(do.call(cbind, lapply(filtered_tnbc_data, summary)))
```

*This code was inspired by the response by A5C1D2H2I1M1N2O1R2T1 to this Stack Overflow question [@chiam2015].*

The 1st quantile is no longer 0 and the median has increased significantly.

---

## Identifier Mapping

Until now, we have been using the ENSEMBL gene ids to map our data. While ENSEMBL is quite common for gene identifiers, most tools use the HGNC name for each gene instead. Our dataset already stores the HGNC symbols for each gene in the `external_gene_id` column. 

We could have dealt with these genes earlier, however, there are some duplicates in the HGNC symbols so we must deal with them first before setting the gene symbols. We let filtering take care of some of these lowly-expressed genes first, and now we can analyze the remaining duplicated genes.


```{r, message=FALSE, warning=FALSE}
# identify duplicate gene identifiers in the tnbc_data
dup_genes <- tnbc_data[duplicated(tnbc_data$external_gene_id),]

# retrieve duplicate ids in filtered_tnbc_data
filtered_dup_genes <- rownames(filtered_tnbc_data)[rownames(filtered_tnbc_data) %in% dup_genes$ensembl_gene_id]
tnbc_data[filtered_dup_genes, c("ensembl_gene_id", "external_gene_id")]
```

Removing lowly-expressed genes has removed the duplicates for `LINC01481` and `Metazoa_SRP`, so we only have to deal with `Y_RNA`. We can analyze the expression values to see if there is a lot of variance between the three genes.

```{r, message=FALSE, warning=FALSE}
# retrieve counts for duplicated data
filtered_dup_tnbc_data <- data.frame(filtered_tnbc_data[rownames(filtered_tnbc_data) %in% c("ENSG00000207034", "ENSG00000202019", "ENSG00000222852"), ])

# reshape the data from wide to long format for plotting
plot_filtered_dup_tnbc_data <- filtered_dup_tnbc_data
plot_filtered_dup_tnbc_data$gene <- rownames(filtered_dup_tnbc_data)
plot_filtered_dup_tnbc_data <- plot_filtered_dup_tnbc_data %>%
  pivot_longer(cols = -gene, names_to = "sample", values_to = "expression")

# plot the expression data per sample for Y_RNA
ggplot(plot_filtered_dup_tnbc_data, aes(x = sample, y = expression, color = gene, group = gene)) +
  # draw line 
  geom_line(size = 1) + 
  # draw points
  geom_point(size = 2) + 
  theme_minimal() +
  labs(title = "Y_RNA Gene Counts Across Samples",
       x = "Sample",
       y = "Counts") +
  # angle text so sample is readable
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

The `Y_RNA` genes generally follow a similar trend across samples, so we will take the mean of the expression value as the read counts for `Y_RNA`.

```{r, message=FALSE, warning=FALSE}
# create a column for HGNC symbols
filtered_tnbc_data$hgnc <- tnbc_data$external_gene_id[match(rownames(filtered_tnbc_data), rownames(tnbc_data))]

# group by hgnc symbols and remove duplicates
filtered_tnbc_data <- filtered_tnbc_data %>% 
  dplyr::group_by(hgnc) %>% 
  dplyr::summarise(dplyr::across(where(is.numeric), \(x) mean(x, na.rm = TRUE)))

# remove hgnc symbol column in clean version
clean_tnbc_data <- data.frame(filtered_tnbc_data[ , !(colnames(filtered_tnbc_data) %in% c("hgnc"))])

# set rownames to hgnc symbols
rownames(clean_tnbc_data) <- filtered_tnbc_data$hgnc
```

*This code was inspired by the response by Greg to this Stack Overflow question [@elrey2022].*

Now our data is clean and ready for normalization!

---

## Quality Checks
```{r, message=FALSE, warning=FALSE}
# ensure the dataset contains only numeric values
data_numeric_check <- !all(sapply(clean_tnbc_data, is.numeric))

# count missing values (NAs) in the dataset
na_count <- sum(is.na(clean_tnbc_data))

data.frame(
  check = c("Dataset contains non-numeric data", 
            "Dataset cntains missing values (NAs)"),
  result = c(as.logical(data_numeric_check), as.logical(na_count)),
  stringsAsFactors = FALSE
)
```

Here is a snapshot of our data now.

```{r, message=FALSE, warning=FALSE}
clean_tnbc_data[1:5, ]
```


Our data is now clean and ready for normalization!

---

# Data Normalization

In RNA-Seq analysis, the raw counts of gene expression can be affected by various factors that are not related to the biological differences we aim to study. These factors include technical variation from experimental procedures, sample preparation, and sequencing condition. **Normalization** is a process that aims to standardize these technical differences in order to reduce variability so that the observed differences in gene expression reflect *biological* variability instead of *technical* variability. For this analysis, we will be using the `edgeR` package [@edgeR].

Let's take a look at the distribution of our data before we begin any normalization.

```{r, message=FALSE, warning=FALSE}
plot_count_distribution <- function(count_data, title = "RNASeq Samples") {
  data2plot <- log2(count_data)
  boxplot(data2plot, xlab = "Samples", ylab = "log2 TPM",
    las = 2, cex = 0.5, cex.lab = 0.5,
    cex.axis = 0.5, main = "RNASeq Samples")
  #draw the median on each box plot
  abline(h = median(apply(data2plot, 2, median)),
    col = "green", lwd = 0.6, lty = "dashed")
  
  counts_density <- apply(log2(count_data), 2, density)
    #calculate the limits across all the samples
    xlim <- 0; ylim <- 0
    for (i in 1:length(counts_density)) {
      xlim <- range(c(xlim, counts_density[[i]]$x));
      ylim <- range(c(ylim, counts_density[[i]]$y))
    }
    cols <- rainbow(length(counts_density))
    ltys <- rep(1, length(counts_density))
    #plot the first density plot to initialize the plot
    plot(counts_density[[1]], xlim=xlim, ylim=ylim, type="n",
      ylab="Smoothing density of log2-CPM",
      main=paste(title, "- Density Plot"), cex.lab = 0.85)
    #plot each line
    for (i in 1:length(counts_density))
      lines(counts_density[[i]], col=cols[i], lty=ltys[i])
    #create legend
    legend("topright", colnames(data2plot),
      col=cols, lty=ltys, cex=0.75,
      border ="blue", text.col = "green4",
      merge = TRUE, bg = "gray90")
}

plot_count_distribution(clean_tnbc_data, title = "Clean TNBC Data")
```

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*

A common method for normalizing out technical variation is **Trimmed Mean of M-values (TMM)**, which is a sample-based normalization method based on the hypothesis that most genes are not differentially expressed [CITATION]. This method normalizes data by selecting a reference sample, calculating fold changes relative to it, and trimming out differentially expressed genes. The trimmed mean of fold changes and the total count of the sample are then used to scale the read counts [@evans2017].

```{r, message=FALSE, warning=FALSE}
tnbc_dge_list <- edgeR::DGEList(counts=clean_tnbc_data, group=sample_df$diseaseState)
tnbc_dge_list <- calcNormFactors(tnbc_dge_list)
normalized_tnbc_counts <- cpm(tnbc_dge_list)
```

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*

We can now re-inspect our data distribution to see that the data is more normalized. Normalized data should have more aligned means across samples, with the distribution more centered and resembling a normal distribution.

```{r, message=FALSE, warning=FALSE}
plot_count_distribution(normalized_tnbc_counts, title = "Filtered TNBC Data")
```

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*

---

## Data Separation By Sample

A good way to visualize the relationship between samples is through a **Multidimensional Scaling (MDS)** plot. This plot helps us assess the similarities between samples based on their expression profiles [@hout2013]. By applying MDS, we can check how well the samples are grouped by their biological characteristics, such as disease state [@hout2013].

In the MDS plot, samples that are similar in gene expression should cluster together, while samples that are very different should be placed farther apart.

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*
```{r, message=FALSE, warning=FALSE}
limma::plotMDS(tnbc_dge_list, labels=NULL, pch = 1,
               col = c("darkgreen","blue")[factor(sample_df$diseaseState)])

legend("topright", 
       legend=levels(factor(sample_df$diseaseState)),
  pch=c(1), col= c("darkgreen","blue"),title="Class",
  bty = 'n', cex = 0.75)
```

Here we see that there is a nice separation of data between disease states! This means there may be a good amount of differentially expressed genes across our disease states.

---

## Dataset Variance 

The **dispersion** of the dataset represents how much the variance deviates from the mean across the samples. In RNA-Seq data, we expect the variance to follow a negative binomial distribution, with the variance increasing with the mean expression level [@anders2013].

By calculating dispersion, we can see the consistency of gene expression across samples. A large dispersion suggests that there is large variability in gene expression, which could either be biologically meaningful or technical variation.

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*
```{r, message=FALSE, warning=FALSE}
model_design <- model.matrix(~sample_df$diseaseState)
tnbc_dispersion <- estimateDisp(tnbc_dge_list, model_design)
plotBCV(tnbc_dispersion,col.tagwise = "black",col.common = "red",)
```

We will now examine the overall distribution of variance across all genes. In particular, we want to examine whether the variance increases with the mean expression levels following the negative binomial distribution [@anders2013]. If the variance is unevenly distributed or significantly deviating from the negative binomial distribution, it may cause issues later when performing differential gene analysis.

*This code was modified from the lectures for BCB420: Computational Systems Biology [@isserlin2025].*
```{r, message=FALSE, warning=FALSE}
plotMeanVar(tnbc_dispersion, show.raw.vars = TRUE,
show.tagwise.vars=TRUE, NBline=TRUE,
show.ave.raw.vars = TRUE,show.binned.common.disp.vars = TRUE)
```

From our analysis, we find that the dataset involves a high degree of variance, but after several rounds of correction it tends to follow the negative binomial model.

```{r, message=FALSE, warning=FALSE}
dim(clean_tnbc_data)
```

---

# Discussion

In the process of cleaning and normalizing the data, we are left with `3690` genes from the neutorphils of 7 mTNBC patients and 7 healthy donors. All ensembl ids were mapped to HGNC symbols by the original authors. There were 3 duplicate ensembl ids for `Y_RNA`, whos read counts were averaged since their general trend was similar across genes.


# References

