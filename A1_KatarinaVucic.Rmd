---
title: "Title"
output: 
  html_document:
    toc: true
    toc_depth: 2
bibliography: references.bib
---

Triple-Negative Breast Cancer (TNBC) is a particulary aggressive breast cancer with a high mortality rate. To investigate the immune response in TNBC patients, Bakker et. al performed a bulk RNA-seq experiment designed to identify the differences in the expression of immune-cell genes between TNBC and healthy pateints [@bakker2025]. 

In this analysis, we continue the work of Bakker et. al by examining their sequencing results to identify immune-cell specific expression in TNBC patients.

# Dataset Import

We begin our analysis by importing relevant packages for cleaning and analysis.
```{r, message=FALSE, warning=FALSE, error=FALSE, results='hide'}
library(GEOquery)
library(edgeR)
library(ggplot2)
library(reshape2)
```


The authors conducted a bulk RNA-sequencing experiment involving... neutrophils from seven patients with metastatic TNBC (mTNBC). Of the mTNBC pateints, one sample was chemotherapy-na√Øve, one was chemo-free for more than 1 year, and the remaining and 5 received recent chemotherapy. They also sequenced the neutrophils from seven healthy donors (HDs). The results are  stored in GEO with accession number `GSE264108`. We begin by retrieving the dataset, and examining the summary of the experiment we are accessing is detailed below.

```{r, message=FALSE}
data_set_geoid <- "GSE264108"
gse <- getGEO(data_set_geoid, GSEMatrix = FALSE)
gse@header$summary
```

There are two datasets associated with this paper, raw counts and normalized counts. We will be using the raw counts, as we will be doing the normalization from scratch. If the file is downloaded already, the following code will simply import it from your system.

```{r, message=FALSE}
# retrieve the dataset filenames
sfilenames <- getGEOSuppFiles(data_set_geoid, fetch_files = FALSE)

# set dataset filename and working directory for retrieval
data_filename <- sfilenames$fname[1]
download_dir <- file.path(getwd())

# check if the file exists before downloading
if(!file.exists(file.path(download_dir,data_set_geoid, data_filename))){
  sfiles = getGEOSuppFiles(data_set_geoid,
                           baseDir = download_dir, 
                           fetch_files = TRUE)
}

# read in tab-separated data 
tnbc_data <- read.table(
  file.path(download_dir,data_set_geoid,data_filename),
  header=TRUE,
  sep="\t",
  check.names=TRUE)
dim(tnbc_data)
```

This dataset has 9048 immune-cell genes.


# Dataset Cleaning

In order to better understand the data we are working with, we will begin by cleaning up the table as it is now. The columns in our data can be seen below.

```{r}
print(colnames(tnbc_data))
```

There are 14 samples, as well as meta-data for each gene in the data set. To improve our analysis, we split this data into 2 tables, one for the actual read counts and the other for the gene meta-data. 

First, we pull out the sample metadata so that we can map each sample to a more readable descriptor.


```{r}
# retrieve the list of samples
list_of_sample <- gse@gsms

# pull out relevant metadata for each sample
sample_type <- do.call(rbind, 
                        lapply(list_of_sample, FUN=function(x){
                          c(x@header$title,
                            x@header$characteristics_ch1,
                            x@header$treatment_protocol_ch1)}))

# convert to a data frame
sample_df <- as.data.frame(sample_type, stringsAsFactors = FALSE)
colnames(sample_df) <- c("sample", "sampleCondition", "cellType", "diseaseState", "treatmentProtocol")
```


Now, we clean up the dataset so that it is more readable. 
```{r}
# remove matching text to reduce redundancy
sample_df[,'sample'] <- gsub(sample_df[,'sample'],
                                pattern = "Neutrophils ",
                                replacement = "")
sample_df[,'sampleCondition'] <- gsub(sample_df[,'sampleCondition'],
                                             pattern = "tissue: ",
                                             replacement = "")
sample_df[,'cellType'] <- gsub(sample_df[,'cellType'],
                                       pattern = "cell type: ",
                                       replacement = "")
sample_df[,'diseaseState'] <- gsub(sample_df[,'diseaseState'],
                                    pattern = "disease state: ",
                                    replacement = "")

sample_df
```


Next, we map our samples back to the read count dataframe so that we can use the accessions more easily. 

```{r}
# pull out sample geo accessions
geo_accessions <- sapply(list_of_sample, function(x)
  x@header$geo_accession)

# set the colomn names of our data
colnames(tnbc_data)[2:15] <- geo_accessions


tnbc_df <- data.frame(tnbc_data)
# need to average duplicates here
# rownames(tnbc_df) <- tnbc_data$external_gene_id
```

Next, we must convert our gene identifiers to a popular format, HGNC symbols. Our dataset already stores the HGNC symbols in the `external_gene_id` column. 

```{r}
dup_genes <- tnbc_data[duplicated(tnbc_data$external_gene_id),]
print(dup_genes[ , c(1, 20)])
```

```{r}
print(unique(dup_genes$external_gene_id))
```

```{r}
library(gprofiler2)
gostres <- gost(query = dup_genes$ensembl_gene_id, organism = "hsapiens")

head(gostres$result)
```


Now, we make our gene meta-data table so that we can access information for each gene. 

### Clean Data

Now that our dataset is in a suitable format, we will clean the actual data residing in the dataset. First, we begin by analysing the distribution of the data. The 1st quantile is 0 for all samples, and the mean values are very low, implying we have quite a few genes with low read counts.

```{r}
sample_dt <- data.table::data.table(sample_df)
sample_dt[, (count = .N), by = sample_dt$diseaseState]
```

```{r}
summary(tnbc_data[ , 2:15])
```

Since there are 7 of each disease state, we remove any gene that does not have expression in at least 7 of the samples.

```{r}
rownames(tnbc_data) <- tnbc_data$ensembl_gene_id
min_num_samples <- 7
data_matrix <- as.matrix(tnbc_data[ , 2:15])
keep = rowSums(edgeR::cpm(data_matrix) >1) > min_num_samples
filtered_tnbc_data = data_matrix[keep,]
dim(filtered_tnbc_data)
```

This leaves us with 3693 genes that have enough expression to be analyzed downstream.

To confirm we have removed most of our low read counts, we can reasses the distribution of the read coutns across samples.

```{r}
summary(filtered_tnbc_data)
```

The 1st quantile is no longer 0 and the median has increased significantly.

The distribution of our data is now reaching the normal distribution (include plot for before as well).



```{r, message=FALSE, warning=FALSE}
data2plot <- log2(filtered_tnbc_data)
boxplot(data2plot, xlab = "Samples", ylab = "log2 TPM",
  las = 2, cex = 0.5, cex.lab = 0.5,
  cex.axis = 0.5, main = "RNASeq Samples")
#draw the median on each box plot
abline(h = median(apply(data2plot, 2, median)),
  col = "green", lwd = 0.6, lty = "dashed")

counts_density <- apply(log2(filtered_tnbc_data), 2, density)
  #calculate the limits across all the samples
  xlim <- 0; ylim <- 0
  for (i in 1:length(counts_density)) {
    xlim <- range(c(xlim, counts_density[[i]]$x));
    ylim <- range(c(ylim, counts_density[[i]]$y))
  }
  cols <- rainbow(length(counts_density))
  ltys <- rep(1, length(counts_density))
  #plot the first density plot to initialize the plot
  plot(counts_density[[1]], xlim=xlim, ylim=ylim, type="n",
    ylab="Smoothing density of log2-CPM",
    main="", cex.lab = 0.85)
  #plot each line
  for (i in 1:length(counts_density))
    lines(counts_density[[i]], col=cols[i], lty=ltys[i])
  #create legend
  legend("topright", colnames(data2plot),
    col=cols, lty=ltys, cex=0.75,
    border ="blue", text.col = "green4",
    merge = TRUE, bg = "gray90")

```

## Identifier Mapping

Until now, we have been using the ENSEMBL gene ids to map our data. While ENSEMBL is quite common for gene identifiers, most tools use the HGNC name for each gene instead. Our dataset already stores the HGNC symbols for each gene in the `external_gene_id` column. 

We could have dealt with these genes earlier, however, there are some duplicated in the HGNC symbols so we must deal with them first before setting the gene symbols. We let filtering take care of some of them first, and now we can analyze the remaining duplicated genes.

```{r}
# identify duplicate gene identifiers in the tnbc_data
dup_genes <- tnbc_data[duplicated(tnbc_data$external_gene_id),]

# retrieve duplicate ids in filtered_tnbc_data
filtered_dup_genes <- rownames(filtered_tnbc_data)[rownames(filtered_tnbc_data) %in% dup_genes$ensembl_gene_id]
print(tnbc_data[filtered_dup_genes, c("ensembl_gene_id", "external_gene_id")])
```

```{r}
filtered_tnbc_data[c("ENSG00000207034", "ENSG00000202019", "ENSG00000222852"), ]

```

Removing lowly-expressed genes has removed the duplicates for `LINC01481` and `Metazoa_SRP`, so we only have to deal with `Y_RNA`. We can analyze the expression values to see if there is a lot of variance between the three genes.

```{r}
library(ggplot2)
library(tidyr)
# extract expression data for each Y_RNA gene
filtered_dup_tnbc_data <- data.frame(filtered_tnbc_data[c("ENSG00000207034", "ENSG00000202019", "ENSG00000222852"), ])
print(filtered_dup_tnbc_data)
```

Next, we investigate the effect of applying the Trimmed Mean of M-values (TMM) to further normalize our data.

```{r}
d <- edgeR::DGEList(counts=filtered_tnbc_data, group=sample_dt$diseaseState)
d <- calcNormFactors(d)
normalized_counts <- cpm(d)
```

By plotting we see that our data is further normalized.

```{r, message=FALSE, warning=FALSE}
data2plot <- log2(normalized_counts)
boxplot(data2plot, xlab = "Samples", ylab = "log2 TPM",
  las = 2, cex = 0.5, cex.lab = 0.5,
  cex.axis = 0.5, main = "RNASeq Samples")
#draw the median on each box plot
abline(h = median(apply(data2plot, 2, median)),
  col = "green", lwd = 0.6, lty = "dashed")

counts_density <- apply(log2(normalized_counts), 2, density)
  #calculate the limits across all the samples
  xlim <- 0; ylim <- 0
  for (i in 1:length(counts_density)) {
    xlim <- range(c(xlim, counts_density[[i]]$x));
    ylim <- range(c(ylim, counts_density[[i]]$y))
  }
  cols <- rainbow(length(counts_density))
  ltys <- rep(1, length(counts_density))
  #plot the first density plot to initialize the plot
  plot(counts_density[[1]], xlim=xlim, ylim=ylim, type="n",
    ylab="Smoothing density of log2-CPM",
    main="", cex.lab = 0.85)
  #plot each line
  for (i in 1:length(counts_density))
    lines(counts_density[[i]], col=cols[i], lty=ltys[i])
  #create legend
  legend("topright", colnames(data2plot),
    col=cols, lty=ltys, cex=0.75,
    border ="blue", text.col = "green4",
    merge = TRUE, bg = "gray90")
```

Next we use an MDS plot to represent the distances of the data between samples. Here we see that there is a nice separation of data between disease states!
```{r, message=FALSE, warning=FALSE}
limma::plotMDS(d, labels=NULL, pch = 1,
               col = c("darkgreen","blue")[factor(sample_dt$diseaseState)])

legend("topright", 
       legend=levels(factor(sample_dt$diseaseState)),
  pch=c(1), col= c("darkgreen","blue"),title="Class",
  bty = 'n', cex = 0.75)
```

We also calculate dispersion to assess how much the variance of our dataset deviates from the mean.
```{r, message=FALSE, warning=FALSE}
model_design <- model.matrix(~sample_dt$diseaseState)
d <- estimateDisp(d, model_design)
plotBCV(d,col.tagwise = "black",col.common = "red",)
```

We find that there is a lot of variance, and use further plots to investigate.

```{r, message=FALSE, warning=FALSE}
plotMeanVar(d, show.raw.vars = TRUE,
show.tagwise.vars=TRUE, NBline=TRUE,
show.ave.raw.vars = TRUE,show.binned.common.disp.vars = TRUE)
```

We find our dataset does not follow the negative binomial model and includes a high-degree of variance.


# Discussion





