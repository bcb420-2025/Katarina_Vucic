---
title: "Data Cleaning and Processing of RNA-Seq for Triple-Negative Breast Cancer"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
    theme: flatly
    highlight: tango
    fig_caption: true
    df_print: paged 
    code_folding: show
bibliography: references.bib
---


```{r, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, results='hide'}

# NOTE: This section is meant to store function code for the rest of the notebook, and is not viewable in the HTML render. Please disregard this section and move to the markdown text below to access the analysis.

library(GEOquery)
library(edgeR)
library(ggplot2)
library(reshape2)
library(tidyr)
library(dplyr)

plot_count_distribution <- function(count_data, title = "RNASeq Samples") {
  data2plot <- log2(count_data)
  boxplot(data2plot, xlab = "Samples", ylab = "log2 TPM",
    las = 2, cex = 0.5, cex.lab = 0.5,
    cex.axis = 0.5, main = "RNASeq Samples")
  #draw the median on each box plot
  abline(h = median(apply(data2plot, 2, median)),
    col = "green", lwd = 0.6, lty = "dashed")
  
  counts_density <- apply(log2(count_data), 2, density)
    #calculate the limits across all the samples
    xlim <- 0; ylim <- 0
    for (i in 1:length(counts_density)) {
      xlim <- range(c(xlim, counts_density[[i]]$x));
      ylim <- range(c(ylim, counts_density[[i]]$y))
    }
    cols <- rainbow(length(counts_density))
    ltys <- rep(1, length(counts_density))
    #plot the first density plot to initialize the plot
    plot(counts_density[[1]], xlim=xlim, ylim=ylim, type="n",
      ylab="Smoothing density of log2-CPM",
      main=paste(title, "- Density Plot"), cex.lab = 0.85)
    #plot each line
    for (i in 1:length(counts_density))
      lines(counts_density[[i]], col=cols[i], lty=ltys[i])
    #create legend
    legend("topright", colnames(data2plot),
      col=cols, lty=ltys, cex=0.75,
      border ="blue", text.col = "green4",
      merge = TRUE, bg = "gray90")
}
  
```

While cancer is one of the most researched diseases in the world, the immune landscape of cancer patients is largely uncharacterized. Previous studies have shown that the way tumours affect the immune system response can lead to different disease progressions.

Neutrophils are white blood cells that respond to conditions in the body by releasing enzymes to destroy microorganisms. Neutrophils also promote the response of other immune cells, making them vital to the immune system. 

Triple-Negative Breast Cancer (TNBC) is a particularly aggressive breast cancer with a high mortality rate. To investigate immune response in TNBC patients, Bakker et. al performed a bulk RNA-seq experiment designed to identify the differences in the expression of immune-cell genes between TNBC and healthy patients [@bakker2025]. 

In this analysis, we continue the work of Bakker et. al by examining their bulk RNA-sequencing results to identify immune-cell specific expression in TNBC patients.

# Dataset Import

The authors conducted a bulk RNA-sequencing experiment involving neutrophils from seven patients with metastatic TNBC (mTNBC). Of the mTNBC pateints, one sample was chemotherapy-naÃ¯ve, one was chemo-free for more than 1 year, and the remaining 5 received recent chemotherapy. They also sequenced the neutrophils from seven healthy donors (HDs) for a control group. The results are stored in GEO with accession number `GSE264108`. We begin by retrieving the dataset, and examining the summary of the experiment we are accessing is detailed below.

```{r, message=FALSE, warning=FALSE}
data_set_geoid <- "GSE264108"
# retrieve data from GEO
gse <- getGEO(data_set_geoid, GSEMatrix = FALSE)
gse@header$summary
```

There are two datasets associated with this paper, raw counts and normalized counts. We will be using the raw counts, since we will be doing the cleaning and normalization from scratch. If the file is downloaded already, the following code will simply import it from your system.

```{r, message=FALSE, warning=FALSE}
# retrieve the dataset filenames
sfilenames <- getGEOSuppFiles(data_set_geoid, fetch_files = FALSE)

# set dataset filename and working directory for retrieval
data_filename <- sfilenames$fname[1]
#data_filename <- "GSE264108_readcounts.txt.gz"
download_dir <- file.path(getwd())

# check if the file exists before downloading
if(!file.exists(file.path(download_dir,data_set_geoid, data_filename))){
  sfiles = getGEOSuppFiles(data_set_geoid,
                           baseDir = download_dir, 
                           fetch_files = TRUE)
}

# read in tab-separated data 
tnbc_data <- read.table(
  file.path(download_dir,data_set_geoid,data_filename),
  header=TRUE,
  sep="\t",
  check.names=TRUE)
dim(tnbc_data)
```

This dataset contains `r dim(tnbc_data)[1]` genes.


# Dataset Cleaning

In order to better understand the data we are working with, we will begin by cleaning up the table as it is now. The columns in our data can be seen below.

```{r, message=FALSE, warning=FALSE}
print(colnames(tnbc_data))
```

There are 14 samples, as well as meta-data for each gene in the data set. To improve our analysis, we split this data into 2 tables, one for the sample meta-data and another for the read counts.

First, we pull out the sample metadata so that we can map each sample to a more readable descriptor.

```{r, message=FALSE, warning=FALSE}
# retrieve the list of samples
list_of_samples <- gse@gsms

# pull out relevant metadata for each sample
sample_type <- do.call(rbind, 
                        lapply(list_of_samples, FUN=function(x){
                          c(x@header$title,
                            x@header$characteristics_ch1,
                            x@header$treatment_protocol_ch1)}))

# convert to a data frame
sample_df <- as.data.frame(sample_type, stringsAsFactors = FALSE)
colnames(sample_df) <- c("sample", "sampleCondition", "cellType", "diseaseState", "treatmentProtocol")
```

Now, we clean up the dataset so that it is more readable. 
```{r, message=FALSE, warning=FALSE}
# remove matching text to reduce redundancy
sample_df[,'sample'] <- gsub(sample_df[,'sample'],
                                pattern = "Neutrophils ",
                                replacement = "")
sample_df[,'sampleCondition'] <- gsub(sample_df[,'sampleCondition'],
                                             pattern = "tissue: ",
                                             replacement = "")
sample_df[,'cellType'] <- gsub(sample_df[,'cellType'],
                                       pattern = "cell type: ",
                                       replacement = "")
sample_df[,'diseaseState'] <- gsub(sample_df[,'diseaseState'],
                                    pattern = "disease state: ",
                                    replacement = "")

sample_df
```


Next, we map our samples back to the read count dataframe so that we can use the accessions more easily. 

```{r, message=FALSE, warning=FALSE}
# set the colomn names of our data to the sample names
colnames(tnbc_data)[2:15] <- sample_df$sample
```


### Data Cleaning

Now that our dataset is in a suitable format, we will clean the actual data residing in the dataset. First, we begin by analysing the distribution of the data. The 1st quantile is 0 for all samples, and the mean values are very low, implying we have quite a few genes with low read counts.

```{r, message=FALSE, warning=FALSE}
summary(tnbc_data[ , 2:15])
```


Since there are 7 of each disease state, we remove any gene that does not have expression in at least 7 of the samples.

```{r, message=FALSE, warning=FALSE}
rownames(tnbc_data) <- tnbc_data$ensembl_gene_id
min_num_samples <- 7
data_matrix <- as.matrix(tnbc_data[ , 2:15])
keep = rowSums(edgeR::cpm(data_matrix) >1) > min_num_samples
filtered_tnbc_data = data.frame(data_matrix[keep,])
dim(filtered_tnbc_data)
```

This leaves us with 3693 genes that have enough expression to be analyzed downstream. To confirm we have removed most of our low read counts, we can reasses the distribution of the read coutns across samples.

```{r, message=FALSE, warning=FALSE}
summary(filtered_tnbc_data)
```

The 1st quantile is no longer 0 and the median has increased significantly.

```{r, message=FALSE, warning=FALSE}
plot_count_distribution(filtered_tnbc_data, title = "Filtered TNBC Data")
```

## Identifier Mapping

Until now, we have been using the ENSEMBL gene ids to map our data. While ENSEMBL is quite common for gene identifiers, most tools use the HGNC name for each gene instead. Our dataset already stores the HGNC symbols for each gene in the `external_gene_id` column. 

We could have dealt with these genes earlier, however, there are some duplicated in the HGNC symbols so we must deal with them first before setting the gene symbols. We let filtering take care of some of them first, and now we can analyze the remaining duplicated genes.

```{r, message=FALSE, warning=FALSE}
# identify duplicate gene identifiers in the tnbc_data
dup_genes <- tnbc_data[duplicated(tnbc_data$external_gene_id),]

# retrieve duplicate ids in filtered_tnbc_data
filtered_dup_genes <- rownames(filtered_tnbc_data)[rownames(filtered_tnbc_data) %in% dup_genes$ensembl_gene_id]
print(tnbc_data[filtered_dup_genes, c("ensembl_gene_id", "external_gene_id")])
```

```{r, message=FALSE, warning=FALSE}
# retrieve counts for duplicated data
filtered_dup_tnbc_data <- data.frame(filtered_tnbc_data[rownames(filtered_tnbc_data) %in% c("ENSG00000207034", "ENSG00000202019", "ENSG00000222852"), ])
```

Removing lowly-expressed genes has removed the duplicates for `LINC01481` and `Metazoa_SRP`, so we only have to deal with `Y_RNA`. We can analyze the expression values to see if there is a lot of variance between the three genes.

```{r, message=FALSE, warning=FALSE}
plot_filtered_dup_tnbc_data <- filtered_dup_tnbc_data
plot_filtered_dup_tnbc_data$gene <- rownames(filtered_dup_tnbc_data)

# reshape the data from wide to long format
plot_filtered_dup_tnbc_data <- plot_filtered_dup_tnbc_data %>%
  pivot_longer(cols = -gene, names_to = "sample", values_to = "expression")

# plot the expression data per sample for Y_RNA
ggplot(plot_filtered_dup_tnbc_data, aes(x = sample, y = expression, color = gene, group = gene)) +
  # draw line 
  geom_line(size = 1) + 
  # draw points
  geom_point(size = 2) + 
  theme_minimal() +
  labs(title = "Y_RNA Gene Counts Across Samples",
       x = "Sample",
       y = "Counts") +
  # angle text so sample is readable
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

We can see here that they generally follow a similar trend across samples, and so we will take the mean of the expression value.


```{r, message=FALSE, warning=FALSE}
filtered_tnbc_data$hgnc <- tnbc_data$external_gene_id[match(rownames(filtered_tnbc_data), rownames(tnbc_data))]
filtered_tnbc_data <- filtered_tnbc_data %>% 
  dplyr::group_by(hgnc) %>% 
  dplyr::summarise(dplyr::across(where(is.numeric), \(x) mean(x, na.rm = TRUE)))

clean_tnbc_data <- data.frame(filtered_tnbc_data[ , !(colnames(filtered_tnbc_data) %in% c("hgnc"))])
rownames(clean_tnbc_data) <- filtered_tnbc_data$hgnc
```

Now our data is clean and ready for normalization!


## Quality Checks
```{r, message=FALSE, warning=FALSE}
# ensure the dataset contains only numeric values
data_numeric_check <- all(sapply(clean_tnbc_data, is.numeric))

# count missing values (NAs) in the dataset
na_count <- sum(is.na(clean_tnbc_data))

# identify columns (samples) that contain only missing values
na_cols <- colSums(is.na(clean_tnbc_data)) == nrow(clean_tnbc_data)

cat("Quality Check Summary:\n")
cat(" * Dataset contains only numeric data: ", data_numeric_check, "\n")
cat(" * Total Missing Values (NAs):", na_count, "\n")
cat(" * Samples with only NAs:", sum(na_cols), "\n")
```

Here is a snapshot of our data now.

```{r, message=FALSE, warning=FALSE}
clean_tnbc_data[1:5, ]
```


Our data is now clean and ready for normalization!

# Data Normalization

In RNA-Seq analysis, the raw counts of gene expression can be affected by various factors that are not related to the biological differences we aim to study. These factors include technical variation from experimental procedures, sample preparation, and sequencing condition. **Normalization** is a process that aims to standardize these technical differences in order to reduce variability so that the observed differences in gene expression reflect *biological* variability instead of *technical* variability

Let's take a look at the distribution of our data before we begin any normalization.

```{r, message=FALSE, warning=FALSE}
plot_count_distribution(clean_tnbc_data, title = "Clean TNBC Data")
```

A common method for normalizing out technical variation is **Trimmed Mean of M-values (TMM)**, which is a sample-based normalization method based on the hypothesis that most genes are not differentially expressed. 

```{r, message=FALSE, warning=FALSE}
tnbc_dge_list <- edgeR::DGEList(counts=clean_tnbc_data, group=sample_df$diseaseState)
tnbc_dge_list <- calcNormFactors(tnbc_dge_list)
normalized_tnbc_counts <- cpm(tnbc_dge_list)
```

We can now re-inspect our data distribution to see that the data is more normalized. Normalized data should have more aligned means across samples, with the distribution more centered and resembling a normal distribution.

```{r, message=FALSE, warning=FALSE}
plot_count_distribution(normalized_tnbc_counts, title = "Filtered TNBC Data")
```

A good way to visualize the relationship between samples is through a **Multidimensional Scaling (MDS)** plot. This plot helps us assess the distances between samples based on their expression profiles. By applying MDS, we can check how well the samples are grouped by their biological characteristics, such as disease state.

In the MDS plot, samples that are similar in gene expression should cluster together, while samples that are very different should be placed farther apart. A good normalization procedure should lead to a clearer separation of groups in the plot.
```{r, message=FALSE, warning=FALSE}
limma::plotMDS(tnbc_dge_list, labels=NULL, pch = 1,
               col = c("darkgreen","blue")[factor(sample_df$diseaseState)])

legend("topright", 
       legend=levels(factor(sample_df$diseaseState)),
  pch=c(1), col= c("darkgreen","blue"),title="Class",
  bty = 'n', cex = 0.75)
```

Here we see that there is a nice separation of data between disease states! This means there may be a good amount of differentially expressed genes across our disease states.

The **dispersion** of the dataset represents how much the variance deviates from the mean across the samples. In RNA-Seq data, we expect the variance to follow a negative binomial distribution, with the variance increasing with the mean expression level.

By calculating dispersion, we can see the consistency of gene expression across samples. A large dispersion suggests that there is large variability in gene expression, which could either be biologically meaningful or an artifact of the normalization process.

```{r, message=FALSE, warning=FALSE}
model_design <- model.matrix(~sample_df$diseaseState)
tnbc_dispersion <- estimateDisp(tnbc_dge_list, model_design)
plotBCV(tnbc_dispersion,col.tagwise = "black",col.common = "red",)
```

We find that there is a lot of variance, and use further plots to investigate.

After assessing the dispersion of the dataset, we will examine the overall distribution of variance across all genes. This allows us to assess whether the dataset follows the expected variance model and to identify any patterns of variability that might be influenced by technical or biological variance. In particular, we want to examine whether the variance increases with the mean expression levels, as is expected under the negative binomial distribution. If the variance is unevenly distributed or significantlt deviating from the negative binomial distribution, it may cause issues later when performing differential gene analysis.

```{r, message=FALSE, warning=FALSE}
plotMeanVar(tnbc_dispersion, show.raw.vars = TRUE,
show.tagwise.vars=TRUE, NBline=TRUE,
show.ave.raw.vars = TRUE,show.binned.common.disp.vars = TRUE)
```

From our analysis, we find that the dataset involves a high degree of variance and does not follow the negative binomial model.


# Discussion





